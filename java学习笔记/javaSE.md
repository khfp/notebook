<!--
 * @Description: In User Settings Edit
 * @Author: your name
 * @Date: 2019-08-13 15:36:31
 * @LastEditTime: 2020-03-31 10:50:37
 * @LastEditors: Please set LastEditors
 -->
## length() 方法，length 属性和 size() 方法的区别:

* length() 方法是针对字符串来说的，要求一个字符串的长度就要用到它的length()方法；
* length 属性是针对 Java 中的数组来说的，要求数组的长度可以用其 length 属性；
* Java 中的 size() 方法是针对泛型集合说的, 如果想看这个泛型有多少个元素, 就调用此方法来查看!

## equals()与==的区别

* 在基本数据类型中(byte,short,char,int,long,float,double,boolean)(**String不是基本类型**)的比较应使用**==**，比较的是他们的值
* 在复合类型(**类**)中：当他们用 **==** 进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。
* JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地址，对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的。
但在一些类库当中这个方法被覆盖掉了，如String,Integer,Date，在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了。因为Object的equals方法也是用双等号 **==** 进行比较的，所以比较后的结果跟双等号 **==** 的结果相同。

## 数值类型转换精度损失问题

### bit(位)与byte(字节)

* bit代表二进制数位,取值范围位: (仅)0或1，计算机中的最小存储单元，不能够单独寻址。
* byte: 意为字节"是计算机文件大小的基本计算单位；8个位（8bit）组成一个字节(1Byte)，用 于表示计算机中的一个字符。可以存储所有ASCII所有字符（这是它包含8bits的初衷。十进制整数范围[-128,127]或[0, 255]最小的可寻址存储单元
  
### 转换问题

* int 存储需要四个字节 float存储需要四个字节 double存储需要8字节。
* 在大整数(int)转为float时会损失精度(float只能有24位来确定精度，而int是32位)
* int->float long->float long->double 有损
* int->double  int-long 无损

### Java序列化

* 序列化(Serializaion)。序列化是一种将对象以一连串的字节描述的过程，用于解决在对对象流进行读写操作时引发的问题。序列化可以将对象的状态写在流里进行网络传输，或者保存到文件，数据库等系统，并在需要时把该流读取出来重新构造一个相同的对象
* 所有实现序列化的类都必须实现Serializable接口，该接口位与java.lang包中，里面没有包含任何方法。使用一个输出流来构造一个ObjectOutputStream对象，使用该对象的writeObject方法就可以将obj对象写出。
* 如果一个类能被序列化，他的子类也能被序列化。
* static代表类的成员,transient代表对象的临时数据(transient声明一个实例变量，当对象存储时，它的值不需要维持)。因此这两种类型的数据成员不能被序列化。
* 1.需要通过网络发送对象，或对象的状态需要被持久化到数据库或文件中。2.序列化能够实现深复制，即复制引用的对象。
* 外部序列化. 外部序列化与内部序列化的主要区别在于序列化是内置的API,只需要实现Seriazable接口，开发人员不需要编写任何代码就可以实现对象的序列化，而使用外部序列化时Extenrnalizable接口中的读写方法必须有开发人员来实现。
